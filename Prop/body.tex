\section{Introduction}

One of the most challenging aspects of software engineering is
optimizing and performance-debugging one's programs.  \dpw{Explain
how one does performance debugging and what is involved
(found this:  \url{http://www.brendangregg.com/linuxperf.html})  Explain
why it is hard.  Cite evidence.
Note that the advent of big data makes this more important than ever 
\em{today}.  Small
changes in performance mean changes in power and lots of money.  Explain that
the same program or same library can have different performance results 
and require different implementations depending on the
environment.  Perhaps bring in past experience with Hancock and explain
the programmer productivity bottlenecks in that context.  Ideally some data about Hancock
might be nice. }

One way to tackle these problems effectively is to use a \emph{Centaur}-based 
approach to programming~\cite{centaur}.  The ``modern centaur'' is 
part human and part machine, and it exploits the strengths of each.
Typically, the human supplies general knowledge of the external world,
specific knowledge of the problem domain, and life experience.  The
computer supplies the ability to test hypotheses rapidly and reliably,
to search through large spaces rapidly.
When it comes to performance debugging, the human's role is to describe
the set of possible implementations without concern for how these implementations
perform; the machine uses its computational power to search through the space of 
implementations to find the best-performing one for the current environment.

Indeed, researchers have already developed solutions to a variety of specific problems
using this technique.  For instance, ... Representation Synthesis, AutoBahn, implicit
parallelism, super-optimization via stochastic search ...

However, each of the above systems was built from scratch --- a substantial undertaking
that can only be achieved by experts willing to build their own new languages and
compilers, or to dig into the internals of existing languages.  The goal of
this proposal is to design and implement a platform for resource-aware program
synthesis.  This platform will ask users to define:

\begin{enumerate}
\item new domain-specific abstractions for use by client programs
\item the (possibly infinite) space of implementations of each abstraction
\item a cost model
\item a search strategy to navigate the space of implementations
\item data to focus optimization
\end{enumerate}

The first 4 items need only be defined once ---they form a
\emph{resource-aware synthesis module}.  The last item allows
different clients to optimize for different environements.

For example, to implement Hawkin's et al.'s representation synthesis engine, the
engineer defining the resource-aware synthesis module would
specify:

\begin{enumerate}
\item an interface with functions to insert, delete and look up records in a database
\item a description of the implementations, which will be in terms of key-value maps,
including, for instance, a hash table, a list and a vector implementation
\item the cost model is simply the running time
\item the search strategy is brute force enumeration
\end{enumerate}

Then users of that module could supply example data/programs and re-optimize for
their environment.





%\begin{figure}[t]
%% \begin{wrapfigure}{R}{0.4\textwidth}
%%   \centering
%%   \includegraphics[width=.35\textwidth]{figures/errors2} \\
%%   \caption{
%% Juniper study~\cite{juniper-study}: 50-80\% of outages are the result of human error.}
%%   \label{fig:network-downtime}
%% \end{wrapfigure}
%\end{figure}




\paragraph*{Intellectual Merit.}


\paragraph{The Team.}  Our team has the breadth of skills, backgrounds, and perspectives that will be required to accomplish the agenda set out above.  

\paragraph{Broader Impacts.}  

\section{Preliminary Work}
\label{sec:preliminary}

\begin{figure}[t]
    %% \centering
    %% \begin{minipage}{.5\textwidth}
    %%     \centering
    %%     \includegraphics[width=0.6\textwidth]{figures/datacenter-topo}
    %%     \caption{Data Center Topology}
    %%     \label{fig:data-center-topo}
    %% \end{minipage}%
    \begin{minipage}{0.5\textwidth}
        \centering
\begin{mylisting}
 1. random
 2. code
\end{mylisting}
        \caption{Random Figure}
        \label{fig:random}
    \end{minipage}
\end{figure}


\section{Broader Impacts}
\label{sec:impact}


\section{Results from Prior NSF Support}
\label{sec:prior-support}

\noindent
{\bf David Walker, PI. NSF CNS-1111520, Intellectual Merit:}
In NSF CNS-1111520, \emph{High-Level Language Support for Trustworthy Networks}
(\$1,400,000, 08/11-07/16),
PI Walker and his collaborators developed new languages, interfaces
and systems for managing software-defined networks (SDNs).  
This project produced the Frenetic family
of network programming languages, the first high-level languages for
programming software-defined networks.  These languages, which include
Frenetic~\cite{frenetic}, 
Pyretic~\cite{pyretic},
NetKAT~\cite{netkat} and others, all adhere to the
\emph{principle of compositionality}, a key design element missing
from earlier network programming languages.  
%They also invented the
%notion of consistent network update~\cite{reitblatt+:consistent-updates},
%which ensures key safety invariants are preserved across network update.
Open source code for systems produced by this project is available
at \url{frenetic-lang.org}.
%
{\bf Broader Impacts:} 
The PIs held a well-attended summer school on network programming and 
verification for students and faculty. The
Pyretic programming language was used in Nick Feamster's popular
SDN MOOC; thousands of students and
network operators all over the US used it to learn principles of network
programming.  The PIs
also helped create the P4 switch configuration language~\cite{P4}, which is
becoming an industry standard.

\medskip
\noindent
{\bf Kathleen Fisher} 

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "proposal.tex"
%%% TeX-PDF-mode: t
%%% End:
