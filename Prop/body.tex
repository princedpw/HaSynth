
\section{Introduction}
\dpw{One of the most challenging aspects of software engineering is
optimizing and performance-debugging one's programs.  }


When writing robust software, functional correctness is only the
beginning.  High-quality code also needs to make savvy use of
resources.  In modern computer systems, there are many implementation
choices, and the best choices depend upon many factors that may be
only poorly understood by programmers.  Examples of such factors
include difficult-to-predict effects of hardware and/or software
caches, jit compilers, the changing needs of dynamic workloads, and
implementations of lazy language features.   


Overly Specialized.
Even if programmers were able to figure out at a particular point in
time how to get optimal performance on a particular machine with a
particular compiler on a particular set of workloads, such codes are
unlikely to be robust as the hardware/software/workload system
co-evolves.


Premature commitments. 
Library writers face particuarly daunting challenges as the
appropriate implementation choices may depend crucially on information
not available until the library is used.  Exposing different API calls
for different workloads, for example as Haskell's JSON parsing library
does, is a brittle and clumsy mechanism for allowing users to
customize performance.

A different approach to building robust performant systems is to allow
programmers to specify the required functionality of a given piece of
a system \textit{but not the implementation}.  
Instead, the programmer specifies a search space of implementations
and a cost model.   



  good example: database systems. 

Possible solution: centaur-based approach.  


Somewhere we need to mention combination of static and dynamic methods
and argue for why static methods alone are likely to be insufficient.

Goals:
  - help user find programs that are correct and resource-savvy for
  relevant workloads.  ``performance auto-tuning''
  - help user write programs that are robust with respect to workload
  changes.  Devise an infrastructure that allows programmers to specify their
  intent at a high level, and then synthesize a performant
  implementation.  This approach means the system can resynthesize a
  different implementation in response to changes in workload while
  leaving the high-level logic of the program unchanged.  
  - help user find inputs on which current implementation exhibits
  poor resource utlization.  annoying/unsuable and security
  vulnerability as attackers can use these inputs to create denial of
  service attacks. 


\dpw{Explain
how one does performance debugging and what is involved
(found this:  \url{http://www.brendangregg.com/linuxperf.html})  Explain
why it is hard.  Cite evidence.
Note that the advent of big data makes this more important than ever 
\em{today}.  Small
changes in performance mean changes in power and lots of money.  Explain that
the same program or same library can have different performance results 
and require different implementations depending on the
environment.  Perhaps bring in past experience with Hancock and explain
the programmer productivity bottlenecks in that context.  Ideally some data about Hancock
might be nice. 
DARPA program -- performance attacks.
}

One way to tackle these problems effectively is to use a \emph{Centaur}-based 
approach to programming~\cite{centaur}.  The ``modern centaur'' is 
part human and part machine, and it exploits the strengths of each.
Typically, the human supplies general knowledge of the external world,
specific knowledge of the problem domain, and intuition derived from life experience.  The
computer supplies the ability to test hypotheses rapidly and reliably,
to search through large spaces rapidly.
When it comes to performance debugging, the human's role is to describe
the set of possible implementations without concern for how these implementations
perform; the machine uses its computational power to search through the space of 
implementations to find the best-performing one for the current environment.

Indeed, researchers have already developed solutions to a variety of specific problems
using this technique.  For instance, ... Representation Synthesis, AutoBahn, implicit
parallelism, super-optimization via stochastic search ...

However, each of the above systems was built from scratch --- a substantial undertaking
that can only be achieved by experts willing to build their own new languages and
compilers, or to dig into the internals of existing languages.  The goal of
this proposal is to design and implement a platform for resource-aware program
synthesis.  This platform will ask users to define:

\begin{enumerate}
\item new domain-specific abstractions for use by client programs
\item the (possibly infinite) space of implementations of each abstraction
\item a cost model
\item a search strategy to navigate the space of implementations
\item data to focus optimization
\end{enumerate}

The first 4 items need only be defined once ---they form a
\emph{resource-aware synthesis plug-in}.  The last item allows
different clients to optimize for different environements.

For example, to implement Hawkin's et al.'s representation synthesis engine, the
engineer defining the resource-aware synthesis plug-in would
specify:

\begin{enumerate}
\item an interface with functions to insert, delete and look up records in a database
\item a description of the implementations, which will be in terms of key-value maps,
including, for instance, a hash table, a list and a vector implementation
\item the cost model is simply the running time
\item the search strategy is brute force enumeration
\end{enumerate}

Then users of that module could supply example data/programs and re-optimize for
their environment.





%\begin{figure}[t]
%% \begin{wrapfigure}{R}{0.4\textwidth}
%%   \centering
%%   \includegraphics[width=.35\textwidth]{figures/errors2} \\
%%   \caption{
%% Juniper study~\cite{juniper-study}: 50-80\% of outages are the result of human error.}
%%   \label{fig:network-downtime}
%% \end{wrapfigure}
%\end{figure}




\paragraph*{Intellectual Merit.}


\paragraph{The Team.}  Our team has the breadth of skills, backgrounds, and perspectives that will be required to accomplish the agenda set out above.  

\paragraph{Broader Impacts.}  

\section{Preliminary Work}
\label{sec:preliminary}

\begin{figure}[t]
    %% \centering
    %% \begin{minipage}{.5\textwidth}
    %%     \centering
    %%     \includegraphics[width=0.6\textwidth]{figures/datacenter-topo}
    %%     \caption{Data Center Topology}
    %%     \label{fig:data-center-topo}
    %% \end{minipage}%
    \begin{minipage}{0.5\textwidth}
        \centering
\begin{mylisting}
 1. random
 2. code
\end{mylisting}
        \caption{Random Figure}
        \label{fig:random}
    \end{minipage}
\end{figure}


\section{Broader Impacts}
\label{sec:impact}


\section{Results from Prior NSF Support}
\label{sec:prior-support}

\noindent
{\bf David Walker, PI. NSF CNS-1111520, Intellectual Merit:}
In NSF CNS-1111520, \emph{High-Level Language Support for Trustworthy Networks}
(\$1,400,000, 08/11-07/16),
PI Walker and his collaborators developed new languages, interfaces
and systems for managing software-defined networks (SDNs).  
This project produced the Frenetic family
of network programming languages, the first high-level languages for
programming software-defined networks.  These languages, which include
Frenetic~\cite{frenetic}, 
Pyretic~\cite{pyretic},
NetKAT~\cite{netkat} and others, all adhere to the
\emph{principle of compositionality}, a key design element missing
from earlier network programming languages.  
%They also invented the
%notion of consistent network update~\cite{reitblatt+:consistent-updates},
%which ensures key safety invariants are preserved across network update.
Open source code for systems produced by this project is available
at \url{frenetic-lang.org}.
%
{\bf Broader Impacts:} 
The PIs held a well-attended summer school on network programming and 
verification for students and faculty. The
Pyretic programming language was used in Nick Feamster's popular
SDN MOOC; thousands of students and
network operators all over the US used it to learn principles of network
programming.  The PIs
also helped create the P4 switch configuration language~\cite{P4}, which is
becoming an industry standard.

\medskip
\noindent
{\bf Kathleen Fisher} 

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "proposal.tex"
%%% TeX-PDF-mode: t
%%% End:
